\section{Evaluation}
\label{Sec:Evaluation}

	\subsection{Goals and Research Questions}
	\label{Sec:Goals}
	In order to evaluate how effective is our tool in assisting the developers, we empirically evaluated our tool as well as conducted an a user study. We wish to answer the following research questions in our study.
	\begin{description}
		\item[RQ1:] What is the convergence rate for number of unique CSS selectors verses number of DOM states?
		\item[RQ2:] How accurate are the code-completion suggestions provided by the tool?
		\item[RQ3:] How is the quality of code-completion suggestions affected by each phase of our analysis?
		\item[RQ4:] What is the overhead cost (memory) incurred during the DOM Analysis phase?
		\item[RQ5:] What is the overhead cost (time \& memory) incurred during the  Code Analysis phase?
		\item[RQ6:] Does \dompletion make programming tasks faster without compromising correctness of the program?
		\item[RQ7:] Does \dompletion make debugging tasks easier?
	\end{description}
	
	\subsection{Methodology}
	\label{Sec:Methodology}
	The subsection that follow address each of the above questions. An overview of the evaluation methodology we have used to answer each research questions is shown below.
	
	\headbf{RQ1 Approach} To answer this question, we conducted a study on 5 major websites including a few listed in top 100 websites on Alexa\footnote{\url{http://www.alexa.com/topsites}}. We crawled these websites in a random order until the number of unique css selectors become constant.  We then reported the number of DOM states crawled for each website.
	
	\headbf{RQ2: Approach} To answer this question, we used our tool to generate suggestions for an existing php-\javascript based web application. We then manually match the list of generated suggestions to the existing text within the \javascript code. The list of generated suggestions is considered valid if one of the suggestions matches the \css selector used within the code where the code completion was initiated.
	
	\headbf{RQ3: Approach} To answer this question, we modified our tool to include / exclude different analysis phase, therefore affecting the length of suggestions generated by the tool. We then reported the effect of each phase on the results.
	
	\headbf{RQ4: Approach} To answer this question, we crawled different web applications during the crawling phase. We then reported the time required to crawl and analyze these application as well as the system memory consumed during this phase.
	
	\headbf{RQ5: Approach} To answer this question, we used our tool to provide code-completion suggestions on different \javascript code files of varying length. The DOM tree for providing code-completion suggestions is kept constant in this case, therefore only measuring the difference between the time taken to analyze different code files. We then reported the time taken and the amount of memory consumed by the analysis.
	
	\headbf{RQ6: Approach} To answer this question, we conducted a user study where users were asked to write \javascript code, that interacts with the DOM to complete certain tasks. We compared the time taken by users to complete he task with and without our tool.
	
	\headbf{RQ7: Approach} To answer this question, we conducted a study similar to previous question and asked the users to find out some bugs in \javascript-DOM interactions in the given \javascript code. We compared the time taken by the users to complete the task with and without our tool.
	 	
		\begin{figure}
		\centering
		\includegraphics[width=85mm]{images/facebook.pdf}
		\caption{CSS Selectors for user dependent content (Facebook)}
		\label{Fig:Facebook}
	\end{figure}
	\begin{figure}
		\centering
		\includegraphics[width=85mm]{images/wikipedia.pdf}
		\caption{CSS Selectors for user generated content (Wikipedia)}
		\label{Fig:Wikipedia}
	\end{figure}
	\begin{figure}
		\centering
		\includegraphics[width=85mm]{images/bing.pdf}
		\caption{CSS Selectors for Search Engine (Bing)}
		\label{Fig:Bing}
	\end{figure}
	\begin{figure}
		\centering
		\includegraphics[width=85mm]{images/wordpress.pdf}
		\caption{CSS Selectors for blog (Wordpress)}
		\label{Fig:Wordpress}
	\end{figure}
	\begin{figure}
		\centering
		\includegraphics[width=85mm]{images/ajax.pdf}
		\caption{CSS Selectors for AJAX based website (Blog)}
		\label{Fig:AJAX}
	\end{figure}
	
	\subsection{Convergence rate for \css selectors}
	\label{Sec:Convergence}
	To answer RQ1, we crawled 5 web applications: Facebook\footnote{\url{https://www.facebook.com/}} (User specific content), Wikipedia\footnote{\url{https://www.wikipedia.org/}} (User generated content), Bing\footnote{\url{http://www.bing.com/}} (Search Engine), Wordpress Blog\footnote{\url{http://blogs.ubc.ca/karthik/}} and AJAX based blog\footnote{\url{http://www.ece.ubc.ca/~amesbah/}}. All the applications chosen for analysis were dynamic in nature, \ie the DOM tree generated for these websites is either user or input dependent. We also analyzed two blogs where content of DOM tree is dependent on one single user (blog admin) and similar for other user. 
	
	For each web application, we started crawling their home page. We counted the total number of \css selectors, total number of unique \css selectors and total number of minimized \css selectors. For every successive DOM states we included the list of \css selectors from the previous states, therefore only measuring the new \css selectors encountered at each state. 
	
	\figref{Facebook} - \ref{Fig:AJAX} represent the results of analysis at the  end of each DOM state for different websites. As seen from the results, all of the above mentioned websites exhibit patterns in their \css selectors and these patterns tend to converge quickly. The patterns once detected can be used to predict the structure of DOM states that were not encountered during the crawling phase. Therefore, the code-completion system can detect patterns and provide suggestions even for the unseen but similar DOM states.
	
	\finding{DOM states for a particular website exhibit patters in their \css selectors and these patterns tend to converge with increasing number of DOM states. \label{Finding:Convergence}}
	
	
	\begin{figure}
		\centering
		\includegraphics[width=85mm]{images/accuracy.pdf}
		\caption{Code completion suggestions generated using \dompletion}
		\label{Fig:Accuracy}
	\end{figure}
	
	\begin{table}
	{
		\scriptsize
		\begin{tabular}{ p{3.8cm} | p{3.8cm}}
  			\hline                        
  			\textbf{Output} & \textbf{No. of use cases} \\ \hline \hline
  			Valid Suggestions &  40 \\ \hline
			Invalid Suggestions & 7 \\ \hline
			Error & 6 \\ \hline
			Total & 53 \\ 
			\hline  
		\end{tabular}
	}
	\caption {\dompletion evaluation}
	\label{Table:Accuracy}		
	\end{table}
	
	
	
	
	\subsection{Accuracy of \dompletion}
	\label{Sec:Accuracy}
	To answer RQ2, we performed our analysis using an existing php-\javascript based web application Phormer\footnote{\url{http://p.horm.org/er/}}. The choice of web application was based on the following factors:
	\begin{itemize}
		\item \textbf{No use of \javascript libraries:} As our tool \dompletion is in the beginning phase of development, we do not support \javascript libraries. Therefore we prefer to use a web application that does not use libraries. Also we first need to evaluate out tool using native \javascript functions followed by the extension to support \javascript libraries. We discuss about this in detail in \secref{Discussion}.
		
		\item \textbf{Single \javascript file:} All the \javascript code used within this web application was available within a single \javascript file. Therefore making the analysis easier.
		
		\item \textbf{Representative code sample:} The \javascript code used within this application is a representative for a general \javascript code that actively interacts with the DOM. The \javascript file contains 315 lines of code which is good enough for the analysis.
		
	\end{itemize}
	
	In total, there were 53 calls to the \texttt{getElementById} function within the \javascript code. We tried to generate code-completion suggestions for all the calls.    \figref{Accuracy} represents the valid output where the list of suggestions contain the ID that was used within the code. We used the code-completion tool to generate suggestions at Line 300, and see if the element ID used at Line 299 is available in the suggestions. 
	
	\tabref{Accuracy} represents the results of our analysis. As seen from the results, \dompletion can provide code completion suggestions with an accuracy of about 75\%. \dompletion was not able to generate suggestions for some of the \texttt{getElementById} function calls. This was due to the fact that some of the DOM states were not at all explored during the DOM analysis phase. However, a brief information about the web application can improve this accuracy. We also encountered some error cases while analyzing the code. One major reason was improper handling of function parameters. Other reasons include \texttt{http} requests, alert boxes, etc. However, these are just implementation issues and we plan to improve upon these in the next version of our tool.
	
	\finding{\dompletion can provide code-completion suggestions with an accuracy of about 75\% and this accuracy can be improved using application specific information. \label{Finding:Accuracy}}
	
	\subsection{Quality of Suggestions}
	\label{Sec:Suggestions}

	To answer RQ3, we used the same \javascript code as in \secref{Example} for our analysis. We modified the implementation of our tool to include / exclude DOM and Code analysis phase respectively, followed by the analysis of the generated suggestions. We discuss the impact of each phase on code-completion suggestions provided by our tool with respect to the example given in \secref{Example}.
	
	\headbf{DOM Analysis} DOM Analysis phase keeps track of all the elements within the DOM tree. Skipping this phase could affect the quality of suggestions in two ways:
	\begin{description}
		\item[Unable to generate suggestions] If the DOM analysis phase is completely skipped \ie we do not store any information about the DOM tree, then providing code-completion suggestions to user is not possible. For instance, in \figref{Example} at Line 7, when the developer tries to perform code-completion while referring the DOM element using \texttt{getElementById}, the tool will not be able to generate list of possible IDs.
		
		\item[Unable to narrow down the suggestions] Not just the IDs, tag names and class names, we also store the information about the hierarchy of elements in the DOM tree. However, if the hierarchical information is disregarded; at Line 9 when the developer tries to access the children of DOM element, a generic list of suggestions will be generated. This list will reflect all the elements present in the DOM tree. Whereas, given the hierarchical information, we can narrow down to the scope of parent element(s) and provide relevant suggestions. For Line 9, with no hierarchical information the number of suggestions generated is \textbf{23}. Whereas, given the required information our tool generated only \textbf{4} suggestions, out of which 2 were immediate children of the element and the rest 2 were decedents. Two of the suggestions are used by programmer at Line 9 and 10. 
	\end{description}
			
	\headbf{Code Analysis} Code-analysis phase keeps track of all the local variables as well as global variables in scope. Skipping this phase could possibly affect the quality of suggestions in the following way:
	
	\begin{description}
		\item[Missing scope of parent element] Whenever a reference is made to the DOM elements using any of the functions mentioned in \tabref{API}, the scope of DOM elements is used to narrow down the search space. The parent object (either \texttt{document} or \texttt{element}) maps to a particular DOM element and that element acts as the root node for the search space. However, due to lack of information about the parent object, we are unable the parent element in DOM. Therefore search space always starts from the root node \ie complete DOM tree. For any access to DOM the list of suggestions are generic and the results are similar to the previous case where we do not have the hierarchical information of DOM.
	\end{description}

	\finding{Both DOM Analysis and Code Analysis phase are required to provide a list of qualitative code-completion suggestions to the developer. \label{Finding:Quality}}
