\section{Implementation}
\label{Sec:Implementation}

We have implemented the approach described in \secref{Approach} in a tool called \dompletion using \javascript programming language. This tool is built on top of the existing online code editor ACE\footnote{\url{http://ace.c9.io/}}.

For the \textbf{DOM Analysis} phase, we use the Crawljax\cite{crawljax:tweb12} tool to systematically crawl the web application. Other tools such as Selenium\footnote{\url{http://www.seleniumhq.org}} could also be used but these tools require application specific instructions for crawling. Whereas in case of Crawljax, given the website url, Crawljax can automatically start crawling the website. Web developers can also specify application specific sequence to events to crawl specific DOM states and use those states for code-completion purposes. However, in our implementation we just used random crawling therefore making our evaluation unbiased towards any specific web application. We defined two plugins\footnote{\url{https://github.com/crawljax/crawljax/wiki/Writing-a-plugin}} for Crawljax: 1) \texttt{OnNewStatePlugin} and 2) \texttt{PostCrawlingPlugin}. \texttt{OnNewStatePlugin} is used to execute the code whenever a new DOM state is detected during crawling. We used this plugin to create a list of \css selectors for that particular DOM state. \texttt{PostCrawlingPlugin} is used to execute the code when Crawljax has finished crawling. We used this plugin to combine and minimize the lists of CSS selectors.

For the \textbf{Code Analysis} phase, we use Esprima\footnote{\url{http://esprima.org}} (\javascript parser written in \javascript) to parse the \javascript code. Esprima converts the given \javascript into an Abstract Syntax Tree (AST)\footnote{\url{http://en.wikipedia.org/wiki/Abstract_syntax_tree}}. We use the AST to 1) Extract function definitions and the executing code segment and 2) Remove \texttt{if} conditions within the code segments. For dynamic analysis of \javascript code we use the \texttt{Function}\footnote{\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function}} constructor to execute the code segments within the execution environment discussed in \secref{Code-Analysis}.

\headbf{\texttt{new Function} vs. \texttt{eval}\footnote{\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval}}}
Another option to execute the \javascript code segments was using the \texttt{eval()} function. However due to the following limitation we preferred to use the \texttt{Function} constructor. \texttt{eval()} evaluates a string as a \javascript expression within the current execution scope and can access local variables. \texttt{new Function()} parses the \javascript code stored in a string into a function object, which can then be called. It cannot access local variables because the code runs in a separate scope. Since our tool \dompletion is implemented using \javascript we did want to modify any of the \javascript variables within the scope of the tool. Therefore to have a separate scope for executing the code provided by the user we use the method discussed above.

The implementation of \textbf{Suggestion Generation} phase is purely based on the usage of regular expressions to match the \css selectors from the first phase to the \css selectors generated in the second phase.