\section{Approach}
\label{Sec:Approach}

	Our DOM based Code-completion approach consists of 3 phases outlined in \figref{Approach}: 1) DOM analysis, 2) Code analysis, and 3) Suggestion generation. The \emph{DOM analysis} phase involves crawling the web application and generate list of \css selectors present within the DOM states. The \emph{Code analysis} phase involves analyzing the \javascript code, creating list of in-scope variables and intercepting the DOM API calls that include reading and writing to the DOM. The results from the above two phases are passed to the \emph{suggestion generation} phase and combined to generate list of auto-complete suggestions that are presented to the developer. The DOM analysis phase is just executed once when the developer begins writing the code whereas Code analysis phases is executed every time when the developer tries to access the code-completion menu.
	
	\subsection{Usage Model}
	\label{Sec:Model}
		Because we focus on providing auto-complete for DOM based interactions, we assume that the developer has access to the web application under development. If the developer does not have access to the running web application, we assume that the developer has access to the HTML template of the website. Further, we assume that the JavaScript code within the editor is partially complete. By partially complete we refer to \javascript code that is syntactically correct and all the variables in use are defined and there are no global variables in use. The latter assumption is based on the fact that usage of global variables within \javascript code is considered as a bad practice.\footnote{\url{http://stackoverflow.com/questions/10525582/why-are-global-variables-considered-bad-practice-javascript}}
		
		Our approach is designed to provide code completion suggestions for \javascript-DOM interactions within the \javascript code. There is no specific input required form the developer, other than hitting the code-completion menu while writing the code. DOM based code-completion is provided when any of the  functions mentioned in \tabref{API} are written by the developer.
	
	
		The output of our approach is a list of \css selectors which are shown as the developer is typing. The generated list is dependent on 1) \javascript variables in scope 2) Scope of parent element within DOM 3) Additions / deletions made to the DOM within the available code paths.
	
	\subsection{DOM Analysis}
	\label{Sec:DOM-Analysis}
		\begin{figure}
		%	\begin{mdframed}
			\centering
			\includegraphics[width=75mm]{images/overview.pdf}
		%	\end{mdframed}
			\caption{Approach}
			\label{Fig:Approach}
		\end{figure}
		
		In the DOM analysis phase, the corresponding web application is crawled to collect information about the DOM hierarchy and is then stored in the form of \css selectors\footnote{\css selectors are the patterns used to select particular DOM element}. Each leaf node in the DOM is expressed as a sequence of tag name, id's and classnames found in the hierarchy. There list of \css selectors is appended to the existing list and carried forward to the next state. The crawler then checks for left over DOM states for analysis. If there are any existing states available the crawler then moves top that [articular state for analysis.	 Once all encountered DOM states have been analyzed, the \css selectors generated from different DOM states are combined to generate a superset of \css selectors which are then used in the later phase.
		
		\headbf{Converting DOM to \css Representation}
		Every element within the DOM hierarchy can be addressed as a space separated sequence of nodes beginning from the root node. Each node is a DOM element and can be represented as a combination of tag name, id and list of classes attached to the element. For example for \figref{Structure} the \texttt{li} elements can be represented as follows:
			
		\begin{quote}
			\texttt{body.home.blog.custom-font-enabled.single-author div\#page.hfeed.site header\#masthead.site-header nav\#site-navigation.main-navigation div.nav-menu ul li.current\_page\_item} \\
			
			\texttt{body.home.blog.custom-font-enabled.single-author div\#page.hfeed.site header\#masthead.site-header nav\#site-navigation.main-navigation div.nav-menu ul li.current\_page\_item2}
		\end{quote}
			
		To represent complete DOM tree in terms of \css selectors, we focus on all the leaf nodes within the tree, \ie the elements within DOM that does not have any child element. For every leaf node we generate a sequence of its \css selectors; therefore covering all the DOM elements present within the DOM tree. The list of \css selectors for each DOM state are then accumulated together to generate a superset of \css selector strings. The \css representation of the DOM tree for a single DOM state holds the following properties:
		\begin{itemize}
			 \item Each word represents a node in the DOM tree with a combination of tag name(required), class name(if present) and id(if present).
			 \item Each row starts with the root element and traverses to one of the leaf nodes i.e each row represents one path from root node to leaf nodes.
			\item Number of rows is equal to number of leaf nodes.
			 \item Number of words in each string represents the depth of particular path
		\end{itemize}
		
		As the number of crawled DOM states increases, the number of rows in the \css representation increases exponentially, therefore increasing the space and time complexity of the approach. To effectively provide code-completion suggestions within a decent time frame, we need to minimize the \css representation of the superset that is generated after the timeout is reached.
		
		\begin{description}
			\item[Removing duplicates]
			The two leaf nodes in the DOM tree that follow exact DOM hierarchy \ie they have exactly same \css representation, one of them is removed. For example in \figref{Example} the 2 \texttt{li} elements follows same DOM hierarchy therefore we can consider only one of them for the analysis.
		
			\item[Combining Similar IDs]
			Two rows within the \css based representation that follow the following criteria are the combined to form a single row. 

			\begin{itemize}
				\item The distance between the root node and the leaf node should be equal.
				\item Tag names should be exactly similar at each level of hierarchy.
				\item Classes attached to each tag should be exactly same.
			\end{itemize}

			For example:
			
			\begin{quote}
				\texttt{ul.nav-menu.toggled-on li\#item1}
	
				\texttt{ul.nav-menu.toggled-on li\#item2}
			\end{quote}

			In the above two sequences, distance between root node and leaf node for the both the sequences is 1, tag sequence for the sequences is \texttt{ul li}. Classes attached to each element are exactly same. To replace the above two sequences, we generate a new sequence that has exactly same length, tag sequence and classes attached to those tags. We then combine ids that differ in the original sequences and add all of these in the new sequence. The new sequence generated looks like the following sequence:

			\begin{quote}
				\texttt{ul.nav-menu.toggled-on li\#item1\#item2}
			\end{quote}

			\item[Combining Similar Classes]
			Two rows within the \css based representation that follow the following criteria are the combined to form a single row. 
			
			\begin{itemize}
				\item The distance between the root node and the leaf node should be equal.
				\item Tag names should be exactly similar at each level of hierarchy.
				\item IDs attached to each tag should be exactly same.
			\end{itemize}

			For example:
			\begin{quote}
				\texttt{ul\#nav-menu.toggled-on li.item1}
	
				\texttt{ul\#nav-menu.toggled-on li.item2}
			\end{quote}

			In the above two sequences, distance between root node and leaf node for the both the sequences is 1, tag sequence for the sequences is \texttt{ul li}. Ids attached to each element are exactly same. With the approach similar to the previous case the new sequence is generated.

			\begin{quote}
				\texttt{ul\#nav-menu.toggled-on li.item1.item2}
			\end{quote}
			
			The resulting \css representations might not result in valid \css selectors (such as having two IDs together is invalid). However, we are using this information for code-completion purpose and not for selecting DOM elements.
		
		\end{description}
	
	\subsection{Code Analysis}
	\label{Sec:Code-Analysis}
		
		In the Code Analysis phase, the \javascript code available within the editor is parsed to extract function definitions and the executing code segment. Both the function definition and the executing code segment are then modified to replace the \texttt{if} conditions generating a maximum of $2^n$ different versions, where $n$ is the number of \texttt{if} conditions within that code segments. For each newly generated code path, relevant log statements are inserted within the code to keep track of the code path. Based on the executing code segment, calls are made to each version of function definition therefore covering all the possible code paths. This execution of \javascript code is performed in a secure environment with dummy functions being returned for calls to \texttt{document} or \texttt{window} objects, as well as it intercepts these calls for analysis purpose. The logs generated after the code execution are then analyzed and a list of DOM elements referred in the code is generated. The results of this analysis are used as an input for the next phase.
		
		The entire execution of the code is wrapped in \texttt{try-catch} block to avoid any run-time error. It is highly likely to have syntax errors in the under development code. Such errors when encountered are reported to the user for the purpose of correction. Therefore, our approach also catches a large number of errors in the beginning stage only.
		
		
		\begin{figure}
			\medskip
			\begin{lstlisting}
	( function() {
		var nav = document.getElementById( 'site-navigation' ), button, menu;
		button = nav.getElementsByTagName( 'h3' )[0];
		menu   = nav.getElementsByTagName( 'ul' )[0];
		! button;
		dompleteLog("func1 T","");
		return;
		// Hide button if menu is missing or empty.
		if ( ! menu || ! menu.childNodes.length ) {
			button.style.display = 'none';
			return;
		}
		button.onclick = function() {
			if ( -1 == menu.className.indexOf( 'nav-menu' ) )
				menu.className = 'nav-menu';

			if ( -1 != button.className.indexOf( 'toggled-on' ) ) {	
				button.className = button.className.replace( ' toggled-on', '' );
				menu.className = menu.className.replace( ' toggled-on', '' );
			} else {
				button.className += ' toggled-on';
				menu.className += ' toggled-on';
			}
		};
	} )();
			\end{lstlisting}
			\caption{One possible code path within the executing code}
			\label{Fig:Path}
			\end{figure}
			
			
			\begin{figure}
			\medskip
			\begin{lstlisting}
	create #site-navigation, 
	local nav|#site-navigation, 
	create #site-navigation h3, 
	local button|#site-navigation h3, 
	create #site-navigation ul, 
	local menu|#site-navigation ul, 
	func1 T 
			\end{lstlisting}
			\caption{Logs generated after path execution}
			\label{Fig:Logs}
			\end{figure}
			
		
		\headbf{Replacing \texttt{if} conditions}
		When writing code, different actions are performed based on different decisions. Conditional statements like \texttt{if else} are used in the code to indicate these decisions. Each decision creates a new branch within the code therefore increasing the possible number of code paths that can be followed within the code. To provide auto-complete feature, we need to analyze every possible path within the available \javascript code.
		
		These conditions are removed recursively from the code, where each recursion results in 2 different versions of the code and then recursively performing the same task on the new versions. The process is continued until all the conditions are removed from the code. The conditional statement within the \texttt{if} condition will always be executed irrespective of what path does the code takes at that point. In addition to this, log statements are inserted to keep track of the code path followed within that version of code. Loop statement such as \texttt{for} and \texttt{while} could also reflect the possible code paths. However in our implementation, if the loop condition is dependent on the DOM, the code within the loop will be executed at least once. Otherwise number of loops will be dependent on the value of variables within the code. We discuss more about loops in the \secref{Limitations}
		
		For the example given in \figref{Example}, when the developer is trying to access the code-completion functionality while adding new code in the end, there is one function defined from Line 6-32, with the call to the defined function at Line 32. The executing code segment would be Line 32 followed by the code execution in the function. A total of 16 different code paths are generated and the results for the code-completion will reflect all these paths. \figref{Path} represents one possible code path. The first \texttt{if} condition is removed from the code and the code path with \texttt{true} block is executed. Note that the code after Line 7 will not be executed due to the execution of \texttt{return} statement. The logs generated after executing this code path are presented in \figref{Logs}.	
		
		
				
			\begin{figure}
			\medskip
			\begin{lstlisting}
	if(document.getElementById != undefined) { 
		document._oldGetElementById = document.getElementById; 
			
		document.getElementById = function(id) { 
			var result = document._oldGetElementById(id); 
				
			if (!result) { 
				addInnerHTML(document,"<div id=\'" + id + "\'></div>"); 
				result = document._oldGetElementById(id); 
				result = createProxy(result,document.csspath + " #" + id); 
			} 
			result.appended = true;
			result = createProxy(result,document.csspath + " #" + id);
			dompleteLog("create " + result.csspath,"");
			return result; 
		}; 
	}
			\end{lstlisting}
			\caption{Intercepting calls to \texttt{getElementById} function}
			\label{Fig:Environment}
			\end{figure}
			
		
		\headbf{Execution Environment}
			\javascript code contains references to global objects available within the browser. These objects can be classified into two main categories: 1) Browser Objects and 2) HTML DOM Objects. Browser objects include window\footnote{\url{http://www.w3schools.com/jsref/obj_window.asp}}, navigator\footnote{\url{http://www.w3schools.com/jsref/obj_navigator.asp}}, screen\footnote{\url{http://www.w3schools.com/jsref/obj_screen.asp}}, history\footnote{\url{http://www.w3schools.com/jsref/obj_history.asp}},  and location\footnote{\url{http://www.w3schools.com/jsref/obj_location.asp}}. HTML DOM objects include document\footnote{\url{http://www.w3schools.com/jsref/dom_obj_document.asp}}, and element\footnote{\url{http://www.w3schools.com/jsref/dom_obj_all.asp}} objects. These objects expose an API that can be used to interact with the browser and the HTML within it. Faulty interactions with these APIs can lead to an unexpected output. Therefore to securely execute the code we need to create a safe execution environment that can prevent these interactions from causing a fault.
			
			To securely execute the \javascript code, we redefine functions within these objects and dummy objects are returned based on the return type of the function. We also insert log statements to keep track about when the particular function was called and what were the parameters passed to it. Additional variables are added for the code analysis purpose. Every reference to DOM element returned by these re-defined functions contains a property named \texttt{csspath} to keep track of the \css selectors attached to that element. \figref{Environment} provides an example where a call to \texttt{getElementById()} function is being intercepted.

	
	\subsection{Suggestion Generation}
	\label{Sec:Suggestions}
		
		The outputs from the DOM analysis and Code analysis phase are used as an input to the Suggestion generation phase. The references to DOM generated in code analysis phase are matched against the CSS selectors generated in the DOM analysis phase. Anomalies with respect to DOM elements are then highlighted and presented to the user. Possible effects of DOM modifications within the \javascript code are also analyzed. The results of the analysis are used to generate the possible DOM states. These DOM states in combination with the input specified in the \secref{Model} are matched using regular expressions to provide code-completion suggestions to the user. The suggestions presented to the user reflect the scope of parent element within the new DOM.
		
					\begin{figure}
			\medskip
			\begin{lstlisting}
		re1 = /[^#\\. ]*(?=[ \\.#])#site-navigation(\\.[^\\.# ]+)*(\\([^\\)]+\\))*(?=[ ])/;
			
		re2 = /h3(#[^#\\. ]+)*(?=[ \\.])(\\.[^\\.# ]+)*(\\([^\\)]+\\))*(?=[ ])/;
			\end{lstlisting}
			\caption{First regular expression matches any type of DOM element with \texttt{id=`site-navigation'} and any number of classes attached to it. Second regular expression matches all the \texttt{h3} tags with any id and any number of classes attached to them, within the child elements of the previously matched element.}
			\label{Fig:RegExp}
			\end{figure}
		\headbf{Creating Regular Expressions for matching}
			All the DOM variables within the \javascript code have an additional property \texttt{csspath} (refer to previous section) attached to them. A regular expression is generated to match the superset of DOM elements within the generated DOM that contains the sequence of \css selectors mentioned in the \texttt{csspath} variable. These DOM elements act as a possible parent for the current code-completion context. All the child elements for these parent elements are then combined to generate code-completion suggestions. \figref{RegExp} represents regular expressions for the value of \texttt{button.csspath} variable \ie \texttt{`\#site-navigation h3'} at Line 9 in \figref{Example}.
		
		